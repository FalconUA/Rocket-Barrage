Игра "..." (Пока ещё не придумано название)
===========================================


КАК КОМПИЛИРОВАТЬ?
------------------

Поскольку для вывод графики используется библиотека [SFML 2.1](http://www.sfml-dev.org) (Извините, что-то стукнуло мне в голову и я вдруг решил решил его использовать), так что придётся его установить. К счастью, никто из вас не работает на Линуксе (Вообще на линуксе установка любой библиотеки рано или поздно превратится в полный пи****). Так что, думаю, установить его не будет для вас проблемой (вот Паша видимо уже установил и разобрался с ним). Скачать его можно на [сайте SFML](http://www.sfml-dev.org/download.php). И под виндоусом могут возникать проблемы если  вы будете использовать Code::Blocks, на Visual Studio будет меньше геморроя.

Для тех кто используют QT Creator в качестве среды программирования, параметры компиляции описаны в *.pro файле (это если у вас уже каким-то образом установлены), иначе так же приходится вручную прописать параметры. 
Для тех кто используют другие среды программирования, в интернете есть много примеров установки (если что - я помогу, ведь я ж без вашего разрешения начал использовать эту библиотеку).

Не забудьте добавить папку "Tiny" в список компилируемых файлов, там хранится парсер *.xml файлов (для считывание карты). И так же не забудьте скопировать файл "Resources" в папке дебага/релиза (иначе не сможет найти карту и шрифты). И да, не забудьте при вызове методов движка указать пространство имени rbw (или просто прописать в начале using namespace rbw;).


КОММЕНТ КАСАЕТСЯ ИГОРЯ (ДЛЯ ПАШИ БУДЕТ НИЖЕ): 
---------------------------------------------

Карту я считываю с помощью специального парсера, описанного в level.h и level.cpp, но это не важно. Главное, что все эти стены считывается в вектор типов sf::Rect, у которого есть 4 важные параметры: rect.left, rect.top (координаты x, y левого верхнего угла), rect.width, rect.height (длина и высота). Вся физика прописана в файлах worldphysic.h и worldphysic.cpp (поиск точек пересечение, зеркального вектора и т.д.). Вам может показаться что алгоритм поиска немножко не оптимальный из-за лишних проверок, но, поверьте мне, там есть некоторые тонкости при расчётах с floating-point numbers, и без этих дополнительных проверок не обойтись. Так же не думаю что следует слышком заморачиваться с расчётом точного момента состыкания, поскольку точность всёравно теряется. Можно просто рассмотреть все ракеты, которые находятся в некотором квадрате около бота.

Поскольку ракеты - чрезвычайно динамические объекты в плане создание/уничтожение то я решил использовать так называемые "связные списки" для хранение информации о ракет, поскольку такая структура данных позволяет добавлять/удалять элементов за О(1). Скорость доступа к конкретному элементу при этом ухудшается до О(N), но нам это и не важно поскольку мы всёравно пробегаем всю цепочку (так или иначе тратится как минимум О(N) операции). Что это значит? Это значит, что я храню их в виде "цепочки", каждый элемент цепочки - это набор из трёх указателей: 
1. Указатель на предыдущий элемент цепочки (если это первый элемент, то указатель на предыдущей пустой, т.е NULL)
2. Указатель на ракету 
3. Указатель на следующий элемент цепочки (если это последний элемент, то указатель на предыдущей пустой, т.е NULL)

Поскольку ракеты бывают трёх типов, то я создал три типа цепочков соответственно. Описание цепочков указано ниже. Пример извлечение информации из цепочек приведено в функции rbw::GetObjects класса WorldSimulator. Какие именно информации можно извлечь ? Координаты ракет, координаты игроков, вектор скорости каждого из игроков и ракет. Причём длина вектора равна значению скорости и выражается в "пикселей на милисекунду". Это позволяет 
игре работать на всех компьютерах одинаково. Правда это немножко усложнают расчёты движка, но, поверьте мне, упростит жизнь бота и разработчика бота. И вообще, поскольку разработчик бота с первых же днях анал. геома показал своими идеями с производных что он чистый физик, то, думаю, ему будет проще если есть понятие "время" и "единица расстоянии". Двигаться можно только в определённых направлениях: вверх, вниз, влево, право. (Направлении можно комбинировать, т.е двигаться строго по диагонали. 

Вся информация о "игровом мире" находится в переменной worldInfo типа struct WorldInformation класса WorldSimulator, в том числе и счётчик времени. Все константы (скорость, дамаг и т.д) находится в файле worldconstant.h. Извлекай всё что хочешь, даже можешь нарушать инкапсуляцию - главное чтоб работало =)).


КОММЕНТ КАСАЕТСЯ ПАШИ:
----------------------
Единственная задача серверного класса - обеспечить связь между клиентских классов. А вот задача самого сервера - это синхронизировать данные между "игровым миром" и игроками. "Игровой мир" - это игровой движок, которая должна быть одинаковой всегда и везде. Кст ты говорил что тебе нечего писать - извини, я сильно тормозил над игровым движком, в следствии чего я затормозил всю команду (прошёл половина майских каникул и я только сейчас отсылаю результаты). Но в переди ещё много дел))) Самое главное из них - мерж (т.е соединить все куски кода в одно целое). Итак, ниже в этом тексте будем считать, что под словом "сервер" подразумевается "серверный класс", а под словом клиент - "клиентский класс".

Так вот, обрати внимание на описание класса WorldSimulator в файле worldsimulator.h. Этот класс я спроектировал максимально замкнуто для облегчение работы с другими модулями (для облегчение процесса мерджа). При создании игры, ты создаёшь новый поток, а в нём - новый "мир", то есть создаёшь поток в котором создаётся новый экземпляр класса WorldSimulator, загружаешь карты и т.д (пример инициализации игры в main.cpp). При регистрации игрока, твой сервак сохраняет адреса ай-пи и т.д (всё что там считаешь нужным), и вызывает метод AddPlayer класса WorldSimulator (надеюсь название параметров метода в коде достаточно понятен). Так же при добавлении новой Ракеты-Магнитки/Ракеты-попрыгунчики/Гранаты вызываются методы AddHomingMissile/AddBouncingBomb/AddGrenade соответсвтвенно. Кстати, в "Игровом мире" есть свой таймер, так что можно не мерить FPS и так далее, а написать что-то типа:
> while (No_apocalypsis_in_this_game_world){
> ...
> // Делаем всё что нужно с этими сокетами, принимаем всякие информации
> ...
> world.SimulateNextStep();
> }
Скорость объектов в игре от этого не изменится. Динамика игры будет стабильной для всех компьютеров, даже для самых слабых.

Обрати внимание, что из "игрового мира" WorldSimulator можно извлечь вектор имени мёртвых игроков, а так же параметры всех объектов (структура GraphicObject, я знаю, что эта структура выглядит не эстетично, но, насколько я помню, передавать всё одним вектором вроде легче чем передавать три вектора?). Эти методы нужно вызывать после каждого шага симуляции и мгновенно отсылать игрокам. Как договорились ранее, мы всё будем вычислять на сервере, и в каждый момент времени будем передавать координаты всех объектов. Да, я понимаю что многое из вышеописанных ты уже написал, но, опять же повторюсь, для облегчении работы человека который будет все эти куски собирать в цельную кучу, для облегчении дальнейших работ связанных с улучшением / добавлением новых фичей, и, самое главное, для обеспечение единой физики, единого игровой динамики и в онлайн режиме, и в оффлайн режиме, лучше чтоб игровой движок был единственным. 

А да, ты спрашивал как, по моему мнению, всё это должен работать: 
Клиентский класс где-то будет хранить "свежие обновления" желательно должен иметь все экспортируемые функции класса WorldSimulator, а именно:
* AddHomingMissile(sf::Vector2i MousePosition); // действие игрока, функция будет отсылать запрос серверу
* AddBouncingBomb(sf::Vector2i MousePosition); // действие игрока, функция будет отсылать запрос серверу
* AddGrenade(sf::Vector2i MousePosition); // действие игрока, функция будет отсылать запрос серверу
Где-то в клиетском классе должна быть вектор типа GraphicObject и вектор имён умерших игроков. Эти векторы обновляются сразу же после соответствующего сообщения от сервера (как говорилось выше, после каждого шага симуляции сервер отсылает список умерших и список объектов типа GraphicObject).
* GetDeadPlayers(); // запрос информации о умерших, никакой запрос не отсылаем серверу, а просто извлекаем информацию от вышеописанных векторов
* GetObjects(std::vector< GraphicObject >* objects); // запрос информации о умерших, никакой запрос не отсылаем серверу, а просто извлекаем информацию от вышеописанных векторов
* Registration(); // Регистрация. Передавай всё что считаешь нужным, отсылаем запрос серверу. Сервер, получив запрос о регистрации, сохраняет информацию игрока (никнейм, ай-пи адрес, команду и т.д) и вызывает метод AddPlayer() игрового мира (класса WorldSimulator), который принадлежит соответствующему потоку.

Для синхронизации с выводом графика на компьютере игрока есть два варианта:
1. Клиентский класс будет вызывать методы графического класса сразу же после обновление информации векторов информации (описанных выше). Этот способ легко реализуемый, но для этого нам придётся больше работать сообща.
2. Клиентский класс сам по себе будет обновлять эти векторы информации объектов. А класс вывода графики и взаимодействии с игроком (в моём исполнении - класс Game в game.cpp и game.h) будет периодически извлекать эти информации. Этот способ хорош тем что нам не придётся ждать друг-друга (не придётся работать сообща), но могут возникать трудности. Т.е, могут возникать ситуации, когда одновременно обновляются векторы и извлекаются. Этих ситуации можно легко пренебречь, используя двоичные семафоры (мьютексы). В QT вроде есть готовая реализация двоичных семафоров.


И НАПОСЛЕДОК
------------
Да, ещё куча работы нужно проделать (в основном из-за торможении с моей стороны). Дико извиняюсь за свою "тормознутость". 
